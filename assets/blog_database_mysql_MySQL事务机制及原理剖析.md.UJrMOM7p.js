import{_ as a,o as s,c as e,U as i}from"./chunks/framework.nmnrFtMU.js";const u=JSON.parse('{"title":"MySQL事务机制及原理剖析","description":"","frontmatter":{"cover":"/blog/database/mysql/images/脏读.png","recommend":false,"tag":["MySQL","事务"],"date":"2023-11-28T21:00:00.000Z"},"headers":[],"relativePath":"blog/database/mysql/MySQL事务机制及原理剖析.md","filePath":"blog/database/mysql/MySQL事务机制及原理剖析.md","lastUpdated":1703552913000}'),n={name:"blog/database/mysql/MySQL事务机制及原理剖析.md"},l=i(`<h1 id="mysql事务机制及原理剖析" tabindex="-1">MySQL事务机制及原理剖析 <a class="header-anchor" href="#mysql事务机制及原理剖析" aria-label="Permalink to &quot;MySQL事务机制及原理剖析&quot;">​</a></h1><h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>众所周知，<code>MySQL</code>数据库的核心功能就是存储数据，通常是整个业务系统中最重要的一层，可谓是整个系统的“大本营”，因此只要<code>MySQL</code>存在些许隐患问题，对于整个系统而言都是致命的。那此刻不妨思考一个问题：</p><blockquote><p><code>MySQL</code>在接受外部数据写入时，有没有可能会发生问题呢？</p></blockquote><p>有人也许会笑着回答：“那怎么可能啊，<code>MySQL</code>在写入数据时怎么会存在问题呢”。</p><p>的确，<code>MySQL</code>本身在写入数据时并不会有问题，就算部署<code>MySQL</code>的机器断电/宕机，其内部也有一套健全的机制确保数据不丢失。但往往风险并不来自于表象，虽然<code>MySQL</code>写入数据没问题，但结合业务来看就会有一个很大的隐患，此话怎讲呐？先看案例：</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 从库存表中扣减商品数量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UPDATE</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`zz_inventory\`</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> SET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ......;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 向订单表、订单详情表中插入订单记录</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INSERT INTO</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`zz_order\`</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> VALUES</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(....);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INSERT INTO</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`zz_order_info\`</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> VALUES</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(....);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 向物流表中插入相应的物流信息</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INSERT INTO</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`zz_logistics\`</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> VALUES</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(....);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>上述的伪<code>SQL</code>中，描述的是一个经典下单业务，先扣库存数量、再增加订单记录、再插入物流信息，按照正常的逻辑来看，上面的<code>SQL</code>也没有问题。但是请仔细想想！实际的项目中，这三组<code>SQL</code>是会由客户端（<code>Java</code>线程）一条条发过来的，假设执行到「增加订单记录」时，<code>Java</code>程序那边抛出了异常，会出现什么问题呢？</p><blockquote><p>乍一想似乎没问题，但仔细一想：Java线程执行时出现异常会导致线程执行中断。</p></blockquote><p>因为<code>Java</code>线程中断了，所以线程不会再向数据库发送「增加订单详情记录、插入物流信息」的<code>SQL</code>，此刻再来想想这个场景，由于增加订单详情和物流信息的<code>SQL</code>都未发送过来，因此必然也不会执行，但此时库存已经扣了，用户钱也付了，但却没有订单和物流信息，这引发的后果估计老板都能杀个程序员祭天了......</p><blockquote><p>其实上面列举的这个案例，在数据库中被称之为事务问题，接下来一起聊一聊。</p></blockquote><h2 id="_1-事务的acid原则" tabindex="-1">1 事务的ACID原则 <a class="header-anchor" href="#_1-事务的acid原则" aria-label="Permalink to &quot;1 事务的ACID原则&quot;">​</a></h2><p>什么是事务呢？事务通常是由一个或一组<code>SQL</code>组成的，组成一个事务的<code>SQL</code>一般都是一个业务操作，例如前面聊到的下单：「扣库存数量、增加订单详情记录、插入物流信息」，这一组<code>SQL</code>就可以组成一个事务。</p><blockquote><p>而数据库的事务一般也要求满足<code>ACID</code>原则，<code>ACID</code>是关系型数据库实现事务机制时必须要遵守的原则。</p></blockquote><p><code>ACID</code>主要涵盖四条原则，即：</p><ul><li><code>A/Atomicity</code>：原子性</li><li><code>C/Consistency</code>：一致性</li><li><code>I/Isolation</code>：独立性/隔离性</li><li><code>D/Durability</code>：持久性</li></ul><p>那这四条原则分别是什么意思呢？接下来一起聊一聊。</p><h3 id="atomicity原子性" tabindex="-1">Atomicity原子性 <a class="header-anchor" href="#atomicity原子性" aria-label="Permalink to &quot;Atomicity原子性&quot;">​</a></h3><p>在MySQL中，原子性，指组成一个事务的一组SQL要么全部执行成功，要么全部执行失败，事务中的一组SQL会被看成一个不可分割的整体，当成一个操作看待。</p><p>好比事务<code>A</code>由①、②、③条<code>SQL</code>组成，那这一个事务中的三条<code>SQL</code>必须全部执行成功，只要其中任意一条执行失败，例如②执行时出现异常了，此时就会导致事务<code>A</code>中的所有操作全部失败。</p><h3 id="consistency一致性" tabindex="-1">Consistency一致性 <a class="header-anchor" href="#consistency一致性" aria-label="Permalink to &quot;Consistency一致性&quot;">​</a></h3><p>一致性也比较好理解，也就是不管事务发生的前后，<code>MySQL</code>中原本的数据变化都是一致的，也就是<code>DB</code>中的数据只允许从一个一致性状态变化为另一个一致性状态。这句话似乎听起来有些绕，不太好理解对嘛？简单解释一下就是：一个事务中的所有操作，要么一起改变数据库中的数据，要么都不改变，对于其他事务而言，数据的变化是一致的，上栗子：</p><blockquote><p>假设此时有一个事务<code>A</code>，这个事务隶属于一个下单操作，由「①扣库存数量、②增加订单详情记录、③插入物流信息」三这条<code>SQL</code>操作组成。</p></blockquote><p>一致性的含义是指：在这个事务执行前，数据库中的数据是处于一致性状态的，而<code>SQL</code>执行完成之后事务提交，数据库中的数据依旧处于一个“一致性”状态，也就是库存数量+订单数量永远是等于最初的库存总数的，比如原本的总库存是<code>10000</code>个，此时库存剩余<code>8888</code>个，那也就代表着必须要有<code>1112</code>条订单数据才行。</p><blockquote><p>这也就是前面说的：“事务发生的前后，<code>MySQL</code>中原本的数据变化都是一致的”，这句话的含义，不可能库存减了，但订单没有增加，这样就会导致数据库整体数据出现不一致。</p></blockquote><p>如果出现库存减了，但订单没有增加的情况，就代表着事务执行过程中出现了异常，此时<code>MySQL</code>就会利用事务回滚机制，将之前减的库存再加回去，确保数据的一致性。</p><blockquote><p>但来思考一个问题，如果事务执行过程中，刚减完库存后，<code>MySQL</code>所在的服务器断电了咋整？似乎无法利用事务回滚机制去确保数据一致性了撒？对于这点大可不必担心，因为<code>MySQL</code>宕机重启后，会通过分析日志的方式恢复数据，确保一致性。</p></blockquote><h3 id="isolation独立性-隔离性" tabindex="-1">Isolation独立性/隔离性 <a class="header-anchor" href="#isolation独立性-隔离性" aria-label="Permalink to &quot;Isolation独立性/隔离性&quot;">​</a></h3><p>简单理解原子性和一致性后，再来看看<code>ACID</code>中的隔离性，在有些地方也称之为独立性，意思就是指多个事务之间都是独立的，相当于每个事务都被装在一个箱子中，每个箱子之间都是隔开的，相互之间并不影响，同样上个栗子：</p><blockquote><p>假设数据库的库存表中，库存数量剩余<code>8888</code>个，此时有<code>A、B</code>两个并发事务，这两个事务都是相同的下单操作，由「①扣库存数量、增②加订单详情记录、③插入物流信息」三这条<code>SQL</code>操作组成。</p></blockquote><p>此时<code>A、B</code>两个事务一起执行，同一时刻执行减库存的<code>SQL</code>，因此这里是并发执行的，那两个事务之间是否会互相影响，导致扣的是同一个库存呢？答案是不会，<code>ACID</code>原则中的隔离性保障了并发事务的顺序执行，一个未完成事务不会影响另外一个未完成事务。</p><h3 id="durability持久性" tabindex="-1">Durability持久性 <a class="header-anchor" href="#durability持久性" aria-label="Permalink to &quot;Durability持久性&quot;">​</a></h3><p>相较于之前的原子性、一致性、隔离性来说，持久性是<code>ACID</code>原则中最容易理解的一条，持久性是指一个事务一旦被提交，它会保持永久性，所更改的数据都会被写入到磁盘做持久化处理，就算<code>MySQL</code>宕机也不会影响数据改变，因为宕机后也可以通过日志恢复数据。</p><h2 id="_2-mysql的事务机制综述" tabindex="-1">2 MySQL的事务机制综述 <a class="header-anchor" href="#_2-mysql的事务机制综述" aria-label="Permalink to &quot;2 MySQL的事务机制综述&quot;">​</a></h2><p>刚刚说到的<code>ACID</code>原则是数据库事务的四个特性，也可以理解为实现事务的基础理论，那接下来一起看看<code>MySQL</code>所提供的事务机制。在<code>MySQL</code>默认情况下，一条<code>SQL</code>会被视为一个单独的事务，同时也无需咱们手动提交，因为默认是开启事务自动提交机制的，如若你想要将多条<code>SQL</code>组成一个事务执行，那需要显式的通过一些事务指令来实现。</p><h3 id="手动管理事务" tabindex="-1">手动管理事务 <a class="header-anchor" href="#手动管理事务" aria-label="Permalink to &quot;手动管理事务&quot;">​</a></h3><p>在<code>MySQL</code>中，提供了一系列事务相关的命令，如下：</p><ul><li><code>start transaction | begin | begin work</code>：开启一个事务</li><li><code>commit</code>：提交一个事务</li><li><code>rollback</code>：回滚一个事务</li></ul><p>当需要使用事务时，可以先通过<code>start transaction</code>命令开启一个事务，如下：</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 开启一个事务</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">start transaction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 第一条SQL语句</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 第二条SQL语句</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 第三条SQL语句</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 提交或回滚事务</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">commit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> rollback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="事务回滚点" tabindex="-1">事务回滚点 <a class="header-anchor" href="#事务回滚点" aria-label="Permalink to &quot;事务回滚点&quot;">​</a></h3><h3 id="mysql隔离机制" tabindex="-1">MySQL隔离机制 <a class="header-anchor" href="#mysql隔离机制" aria-label="Permalink to &quot;MySQL隔离机制&quot;">​</a></h3><h4 id="脏读、不可重复读、幻读问题" tabindex="-1">脏读、不可重复读、幻读问题 <a class="header-anchor" href="#脏读、不可重复读、幻读问题" aria-label="Permalink to &quot;脏读、不可重复读、幻读问题&quot;">​</a></h4><h4 id="事务的四大隔离级别" tabindex="-1">事务的四大隔离级别 <a class="header-anchor" href="#事务的四大隔离级别" aria-label="Permalink to &quot;事务的四大隔离级别&quot;">​</a></h4><h4 id="事务隔离机制的命令" tabindex="-1">事务隔离机制的命令 <a class="header-anchor" href="#事务隔离机制的命令" aria-label="Permalink to &quot;事务隔离机制的命令&quot;">​</a></h4><h2 id="_3-mysql的事务实现原理" tabindex="-1">3 MySQL的事务实现原理 <a class="header-anchor" href="#_3-mysql的事务实现原理" aria-label="Permalink to &quot;3 MySQL的事务实现原理&quot;">​</a></h2><h3 id="正常sql的事务机制" tabindex="-1">正常SQL的事务机制 <a class="header-anchor" href="#正常sql的事务机制" aria-label="Permalink to &quot;正常SQL的事务机制&quot;">​</a></h3><h3 id="多条sql的事务机制" tabindex="-1">多条SQL的事务机制 <a class="header-anchor" href="#多条sql的事务机制" aria-label="Permalink to &quot;多条SQL的事务机制&quot;">​</a></h3><h3 id="事务的恢复机制" tabindex="-1">事务的恢复机制 <a class="header-anchor" href="#事务的恢复机制" aria-label="Permalink to &quot;事务的恢复机制&quot;">​</a></h3><h2 id="_4-mysql事务总结" tabindex="-1">4 MySQL事务总结 <a class="header-anchor" href="#_4-mysql事务总结" aria-label="Permalink to &quot;4 MySQL事务总结&quot;">​</a></h2>`,50),o=[l];function c(d,t,p,r,h,k){return s(),e("div",null,o)}const y=a(n,[["render",c]]);export{u as __pageData,y as default};
