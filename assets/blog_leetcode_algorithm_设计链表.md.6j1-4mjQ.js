import{_ as e,o as n,c as a,R as s}from"./chunks/framework.gZp3ZZFg.js";const d="/assets/设计链表-单向链表1.ycz-vWhI.png",t="/assets/设计链表-单向链表2.lmxMmNMd.png",i="/assets/设计链表-单向链表3.iANBTpQa.png",l="/assets/设计链表-单向链表4.kKRmC_8X.png",p="/assets/设计链表-单向链表5.V0YIOgLe.png",L=JSON.parse('{"title":"设计链表","description":"","frontmatter":{"recommend":false,"tag":["虚拟头节点"],"date":"2023-12-22T14:00:00.000Z"},"headers":[],"relativePath":"blog/leetcode/algorithm/设计链表.md","filePath":"blog/leetcode/algorithm/设计链表.md","lastUpdated":1703552913000}'),o={name:"blog/leetcode/algorithm/设计链表.md"},c=s(`<h1 id="设计链表" tabindex="-1">设计链表 <a class="header-anchor" href="#设计链表" aria-label="Permalink to &quot;设计链表&quot;">​</a></h1><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p><p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。</p><p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p><p>实现 <code>MyLinkedList</code> 类：</p><ul><li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li><li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li><li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li><li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li><li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li><li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li></ul><p><strong>示例：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>输入</span></span>
<span class="line"><span>[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]</span></span>
<span class="line"><span>[[], [1], [3], [1, 2], [1], [1], [1]]</span></span>
<span class="line"><span>输出</span></span>
<span class="line"><span>[null, null, null, null, 2, null, 3]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>解释</span></span>
<span class="line"><span>MyLinkedList myLinkedList = new MyLinkedList();</span></span>
<span class="line"><span>myLinkedList.addAtHead(1);</span></span>
<span class="line"><span>myLinkedList.addAtTail(3);</span></span>
<span class="line"><span>myLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3</span></span>
<span class="line"><span>myLinkedList.get(1);              // 返回 2</span></span>
<span class="line"><span>myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3</span></span>
<span class="line"><span>myLinkedList.get(1);              // 返回 3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>提示：</strong></p><ul><li><code>0 &lt;= index, val &lt;= 1000</code></li><li>请不要使用内置的 LinkedList 库。</li><li>调用 <code>get</code>、<code>addAtHead</code>、<code>addAtTail</code>、<code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的次数不超过 <code>2000</code> 。</li></ul><h2 id="方法一-单向链表" tabindex="-1">方法一：单向链表 <a class="header-anchor" href="#方法一-单向链表" aria-label="Permalink to &quot;方法一：单向链表&quot;">​</a></h2><p>实现单向链表，即每个节点仅存储本身的值和后继节点。除此之外，我们还需要一个哨兵（sentinel）节点作为头节点，和一个 size 参数保存有效节点数。如下图所示。</p><p><img src="`+d+'" alt="设计链表-单向链表1"></p><p>初始化时，只需创建头节点 head 和 size 即可。</p><p>实现 get(index) 时，先判断有效性，再通过循环来找到对应的节点的值。如下图所示。</p><p><img src="'+t+'" alt="设计链表-单向链表2"></p><p>实现 addAtIndex(index, val) 时，如果 index 是有效值，则需要找到原来下标为 index 的节点的前驱节点 pred，并创建新节点 to_add，将to_add 的后继节点设为 pred 的后继节点，将 pred 的后继节点更新为 to_add，这样就将 to_add 插入到了链表中。最后需要更新 size。这样的操作对于 index=0 也成立，如以下两张图所示。</p><p><img src="'+i+'" alt="设计链表-单向链表3.png"></p><p><img src="'+l+'" alt="设计链表-单向链表4.png"></p><p>实现 addAtHead(val) 和 addAtTail(val) 时，可以借助 addAtIndex(index, val) 来实现。</p><p>实现 deleteAtIndex(index) ，先判断参数有效性。然后找到下标为 index 的节点的前驱节点 pred，通过将 pred 的后继节点更新为 pred 的后继节点的后继节点，来达到删除节点的效果。同时也要更新 size。如下图所示。</p><p><img src="'+p+'" alt="设计链表-单向链表5.png"></p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="方法二-双向链表" tabindex="-1">方法二：双向链表 <a class="header-anchor" href="#方法二-双向链表" aria-label="Permalink to &quot;方法二：双向链表&quot;">​</a></h2>',24),r=[c];function u(m,g,b,_,h,v){return n(),a("div",null,r)}const k=e(o,[["render",u]]);export{L as __pageData,k as default};
