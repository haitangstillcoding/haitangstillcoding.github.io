import{_ as a,o as t,c as i,R as r}from"./chunks/framework.gZp3ZZFg.js";const e="/assets/PixPin_2023-11-26_19-02-38.fwlKEjmX.png",o="/assets/PixPin_2023-11-26_19-04-18.WS9FU9m4.png",s="/assets/PixPin_2023-11-26_19-08-27.0Quj6T7L.png",n="/assets/PixPin_2023-11-26_19-10-26.Id9I1lcP.png",l="/assets/PixPin_2023-11-26_19-12-48.f7Z-WXio.png",_="/assets/PixPin_2023-11-26_20-42-03.InMZS49l.png",p="/assets/PixPin_2023-11-26_20-43-40.uBSeqXgn.png",c="/assets/PixPin_2023-11-26_21-10-32.yQLbZppB.png",k="/assets/PixPin_2023-11-26_21-21-34.y-qMt9MF.png",P="/assets/PixPin_2023-11-26_21-37-33.mEkpI8BC.png",h="/assets/PixPin_2023-11-26_21-57-07.OMnPdLo2.png",L=JSON.parse('{"title":"Kafka概述","description":"","frontmatter":{"cover":"/blog/mq/kafka/images/Kafka拓扑结构.png","recommend":false,"tag":["Kafka"],"date":"2023-11-27T21:00:00.000Z"},"headers":[],"relativePath":"blog/mq/kafka/kafka概述.md","filePath":"blog/mq/kafka/kafka概述.md","lastUpdated":null}'),d={name:"blog/mq/kafka/kafka概述.md"},g=r('<h1 id="kafka概述" tabindex="-1">Kafka概述 <a class="header-anchor" href="#kafka概述" aria-label="Permalink to &quot;Kafka概述&quot;">​</a></h1><h2 id="_1-kafka定义" tabindex="-1">1 Kafka定义 <a class="header-anchor" href="#_1-kafka定义" aria-label="Permalink to &quot;1 Kafka定义&quot;">​</a></h2><p>Kafka传统定义：Kafka是一个<strong>分布式</strong>的基于<strong>发布/订阅模式</strong>的<strong>消息队列</strong>(Message Queue)，主要应用于大数据实时处理领域。</p><p>发布/订阅：消息的发布者不会将消息直接发送给特定的订阅者，而是<strong>将发布的消息分为不同的类别</strong>，订阅者<strong>只接收感兴趣的消息</strong>。</p><p>Kafka最新定义：Kafka是一个开源的<strong>分布式事件流平台</strong>（Event Streaming Platform），被数千家公司用于高性能<strong>数据管道</strong>、<strong>流分析</strong>、<strong>数据集成</strong>和<strong>关键任务应用</strong>。</p><h2 id="_2-消息队列" tabindex="-1">2 消息队列 <a class="header-anchor" href="#_2-消息队列" aria-label="Permalink to &quot;2 消息队列&quot;">​</a></h2><p>目前企业中比较常见的消息队列产品主要有Kafka、ActiveMQ、RabbitMQ、RocketMQ等。在大数据场景主要采用Kafka作为消息队列。在JavaEE开发中主要采用ActiveMQ、RabbitMQ、RocketMQ。</p><h3 id="_2-1-传统消息队列的应用场景" tabindex="-1">2.1 传统消息队列的应用场景 <a class="header-anchor" href="#_2-1-传统消息队列的应用场景" aria-label="Permalink to &quot;2.1 传统消息队列的应用场景&quot;">​</a></h3><p>传统的消息队列的主要应用场景包括：<strong>缓冲/消峰</strong>、<strong>解耦</strong>和<strong>异步通信</strong>。</p><h4 id="缓冲-消峰" tabindex="-1">缓冲/消峰 <a class="header-anchor" href="#缓冲-消峰" aria-label="Permalink to &quot;缓冲/消峰&quot;">​</a></h4><p>有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。</p><p><img src="'+e+'" alt="PixPin_2023-11-26_19-02-38"></p><p><img src="'+o+'" alt="PixPin_2023-11-26_19-04-18"></p><h4 id="解耦" tabindex="-1">解耦 <a class="header-anchor" href="#解耦" aria-label="Permalink to &quot;解耦&quot;">​</a></h4><p>允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p><p><img src="'+s+'" alt="PixPin_2023-11-26_19-08-27"></p><h4 id="异步通信" tabindex="-1">异步通信 <a class="header-anchor" href="#异步通信" aria-label="Permalink to &quot;异步通信&quot;">​</a></h4><p>允许用户把一个消息放入队列，但并不立即处理它，然后在需要的时候再去处理它们。</p><p><img src="'+n+'" alt="PixPin_2023-11-26_19-10-26"></p><p><img src="'+l+'" alt="PixPin_2023-11-26_19-12-48"></p><h3 id="_2-2-消息队列的两种模式" tabindex="-1">2.2 消息队列的两种模式 <a class="header-anchor" href="#_2-2-消息队列的两种模式" aria-label="Permalink to &quot;2.2 消息队列的两种模式&quot;">​</a></h3><p>消息队列有点对点模式和发布/订阅模式。</p><h4 id="点对点模式" tabindex="-1">点对点模式 <a class="header-anchor" href="#点对点模式" aria-label="Permalink to &quot;点对点模式&quot;">​</a></h4><ul><li>消费者主动拉取数据，消息收到后清除消息</li></ul><p><img src="'+_+'" alt="PixPin_2023-11-26_20-42-03"></p><h4 id="发布-订阅模式" tabindex="-1">发布/订阅模式 <a class="header-anchor" href="#发布-订阅模式" aria-label="Permalink to &quot;发布/订阅模式&quot;">​</a></h4><p><img src="'+p+'" alt="PixPin_2023-11-26_20-43-40"></p><h2 id="_3-kafka基础架构" tabindex="-1">3 Kafka基础架构 <a class="header-anchor" href="#_3-kafka基础架构" aria-label="Permalink to &quot;3 Kafka基础架构&quot;">​</a></h2><ul><li>Producer：消息生产者，向Kafka broker发消息的客户端。</li><li>Topic：消息源的不同分类。</li><li>Consumer：消息消费者，向Kafka broker取消息的客户端。</li></ul><p><img src="'+c+'" alt="PixPin_2023-11-26_21-10-32"></p><p>随着海量数据的到来，单实例的架构已不满足需求，为方便扩展，并提高吞吐量。</p><ul><li>Kafka Cluster：Kafka实例集群。</li><li>Broker：缓存代理，Kafka集群中的一台或多台服务器统称Broker。</li><li>Partition：Topic物理上的分区，一个Topic可以分为多个Partition，每个Partition是一个有序的队列。</li></ul><p><img src="'+k+'" alt="PixPin_2023-11-26_21-21-34"></p><p>为了配合Partition分区的设计，提出了消费组的概念，组内的每个消费者并行消费。</p><ul><li>Group：消费者组，一个分区的数据只能由组内一个消费者来消费。</li></ul><p><img src="'+P+'" alt="PixPin_2023-11-26_21-37-33"></p><p>为了防止Partition分区故障，为每个Partition分区增加副本，进而提高可用性。</p><p>Leader：Kafka的读写操作，都是发生在Leader上的。Leader负责把数据同步给Follower。当Leader挂了，经过选举后，从多个Follower中选举出新的Leader。</p><p>Follower：接收Leader同步的数据。</p><p><img src="'+h+'" alt="PixPin_2023-11-26_21-57-07"></p>',40),f=[g];function m(u,x,b,q,K,M){return t(),i("div",null,f)}const Q=a(d,[["render",m]]);export{L as __pageData,Q as default};
