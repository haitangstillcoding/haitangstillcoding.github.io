import{_ as e,o as s,c as i,R as a}from"./chunks/framework.gZp3ZZFg.js";const t="/assets/redis数据类型.pYbn7LLV.png",r="/assets/bitmap位图.FqrwW8Kh.png",m=JSON.parse('{"title":"Redis数据类型概述","description":"","frontmatter":{"cover":"/blog/redis/images/redis数据类型.png","recommend":false,"tag":["Redis"],"date":"2023-12-31T00:30:00.000Z","top":2},"headers":[],"relativePath":"blog/redis/Redis数据类型概述.md","filePath":"blog/redis/Redis数据类型概述.md","lastUpdated":null}'),d={name:"blog/redis/Redis数据类型概述.md"},p=a('<h1 id="redis数据类型概述" tabindex="-1">Redis数据类型概述 <a class="header-anchor" href="#redis数据类型概述" aria-label="Permalink to &quot;Redis数据类型概述&quot;">​</a></h1><p>官网：<a href="https://redis.io/docs/data-types/" target="_blank" rel="noreferrer">https://redis.io/docs/data-types/</a></p><p><img src="'+t+'" alt="Redis数据类型"></p><blockquote><p>这里说的数据类型是 value 的数据类型，key 的类型都是字符串。</p></blockquote><h2 id="redis字符串-string" tabindex="-1">Redis字符串（String） <a class="header-anchor" href="#redis字符串-string" aria-label="Permalink to &quot;Redis字符串（String）&quot;">​</a></h2><p>string 是 Redis 最基本的类型，一个 key 对应一个 value。</p><p>string 类型是二进制安全的，意思是 Redis 的 string 可以包含任何数据，比如 jpg 图片或者序列化的对象 。</p><p>String 类型是 Redis 最基本的数据类型，一个 Redis 中字符串 value 最多可以是512M。</p><h2 id="redis列表-list" tabindex="-1">Redis列表（List） <a class="header-anchor" href="#redis列表-list" aria-label="Permalink to &quot;Redis列表（List）&quot;">​</a></h2><p>Redis list 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p>它的底层实际是个双端链表，最多可以包含 2<sup>32</sup> - 1 个元素 （4294967295，每个列表超过40亿个元素）。</p><h2 id="redis哈希表-hash" tabindex="-1">Redis哈希表（Hash） <a class="header-anchor" href="#redis哈希表-hash" aria-label="Permalink to &quot;Redis哈希表（Hash）&quot;">​</a></h2><p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p><p>Redis 中每个 hash 可以存储 2<sup>32</sup> - 1 键值对（40多亿）。</p><h2 id="redis集合-set" tabindex="-1">Redis集合（Set） <a class="header-anchor" href="#redis集合-set" aria-label="Permalink to &quot;Redis集合（Set）&quot;">​</a></h2><p>Redis 的 set 是 string 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，集合对象的编码可以是 intset 或者 hashtable。</p><p>Redis 中 set 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><p>集合中最大的成员数为 2<sup>32</sup> - 1（4294967295，每个集合可存储40多亿个成员）</p><h2 id="redis有序集合-zset" tabindex="-1">Redis有序集合（ZSet） <a class="header-anchor" href="#redis有序集合-zset" aria-label="Permalink to &quot;Redis有序集合（ZSet）&quot;">​</a></h2><p>Redis zset 和 set 一样也是 string 类型元素的集合，且不允许重复的成员。</p><p>不同的是每个元素都会关联一个 double 类型的分数，Redis 正是通过分数来为集合中的成员进行从小到大的排序。</p><p>zset 的成员是唯一的，但分数（score）却可以重复。</p><p>zset 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 2<sup>32</sup> - 1</p><h2 id="redis地理空间-geo" tabindex="-1">Redis地理空间（GEO） <a class="header-anchor" href="#redis地理空间-geo" aria-label="Permalink to &quot;Redis地理空间（GEO）&quot;">​</a></h2><p>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，包括</p><ul><li><p>添加地理位置的坐标。</p></li><li><p>获取地理位置的坐标。</p></li><li><p>计算两个位置之间的距离。</p></li><li><p>根据用户给定的经纬度坐标来获取指定范围内的地理位置集合</p></li></ul><h2 id="redis基数统计-hyperloglog" tabindex="-1">Redis基数统计（HyperLogLog） <a class="header-anchor" href="#redis基数统计-hyperloglog" aria-label="Permalink to &quot;Redis基数统计（HyperLogLog）&quot;">​</a></h2><p>HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2<sup>64</sup> 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><h2 id="redis位图-bitmap" tabindex="-1">Redis位图（bitmap） <a class="header-anchor" href="#redis位图-bitmap" aria-label="Permalink to &quot;Redis位图（bitmap）&quot;">​</a></h2><p>由0和1状态表现的二进制位的 bit 数组</p><p><img src="'+r+'" alt="bitmap位图"></p><h2 id="redis位域-bitfield" tabindex="-1">Redis位域（bitfield） <a class="header-anchor" href="#redis位域-bitfield" aria-label="Permalink to &quot;Redis位域（bitfield）&quot;">​</a></h2><p>通过 bitfield 命令可以一次性操作多个比特位域（指的是连续的多个比特位），它会执行一系列操作并返回一个响应数组，这个数组中的元素对应参数列表中的相应操作的执行结果。</p><p>说白了就是通过 bitfield 命令我们可以一次性对多个比特位域进行操作。</p><h2 id="redis流-stream" tabindex="-1">Redis流（Stream） <a class="header-anchor" href="#redis流-stream" aria-label="Permalink to &quot;Redis流（Stream）&quot;">​</a></h2><p>Redis Stream 是 Redis 5.0 版本新增加的数据结构。</p><p>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅（pub/sub）来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p><p>简单来说发布订阅（pub/sub）可以分发消息，但无法记录历史消息。</p><p>而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p>',41),o=[p];function l(h,n,u,c,R,b){return s(),i("div",null,o)}const _=e(d,[["render",l]]);export{m as __pageData,_ as default};
